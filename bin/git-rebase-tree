#!/bin/bash
#
# Copyright (c) 2008 Benny Halevy <bhalevy@panasas.com>
#
pname=`basename $0`
depfile="$pname.dep"
cmdfile="$pname-cmd.$$"
tagsfix=".orig"
flags=""

usage()
{
	{
	echo "Usage: $pname [options] [--dep depfile] [--tags-suffix string] [branch[:oldbase] ...]"
	echo "Options:"
	echo "  -a --auto         Automatic mode"
	echo "  -c --current:     Start rebasing at Current branch"
	echo "  -f --force:       Force creation of new tags"
	echo "  -h --help:        display this Help message"
	echo "  -i --interactive: git rebase --Interactive mode"
	echo "  -n --notags:      do Not make tags"
	echo "  -p --print:       just Print tree, do not rebase"
	echo "  -r --rmtags:      Remove tags when done"
	echo "  -t --tags-only    just make Tags"
	} 1>&2
	exit 1
}

while [[ "$1" == -* ]]; do
	case "$1" in
	-[acfinprt]*)
		flags=$flags`echo $1 | sed 's/-//'`;;

	--auto*)
		flags=${flags}a;;

	--cur*)
		flags=${flags}c;;

	--force)
		flags=${flags}f;;

	--int*)
		flags=${flags}i;;

	--no*)
		flags=${flags}n;;

	--pr*)
		flags=${flags}p;;

	--rm*)
		flags=${flags}r;;

	--tags-only*)
		flags=${flags}t;;

	(-T|--tags-suffix*)
		tagsfix="$2"
		shift;;

	(-d|--dep*)
		depfile="$2"
		shift;;

	-*)
		usage;;
	esac
	shift
done

cat <<EOF > $cmdfile
#!/bin/bash
#
# shell script automatically generated by $pname
#
# Copyright (c) 2008 Benny Halevy <bhalevy@panasas.com>
#
EOF

cat <<\\EOF >> $cmdfile

[ "$PAGER" = "" ] && PAGER=less

phelp () {
	echo "  y: Yes, do rebase (default)"
	echo "  n: No, skip rebase"
	echo "  a: Automatic mode"
	echo "  e: Edit rebase command"
	echo "  i: Interactive rebase"
	echo "  l: List changes in base..branch"
	echo "  q: Quit program"
}

do_branch () {
	cmd=$1
	newbase=$2
	upstream=$3
	branch=$4
	ans=$5
	echo "$cmd" | grep -q -- --interactive; imode=$?
	cmd="$cmd -m --onto $newbase $upstream $branch"
	t=`git show-ref --hash --heads --tags $newbase`
	if [ $imode != 0 ] && \
	   git rev-list "$newbase^..$branch" | grep -q $t; then
		if [[ "$ans" == [Aa] ]]; then
			ans=s
		else
			read -s -n 1 -p "$branch seems to be already based at $newbase. Rebase anyway [y/N/q]? " ans; echo
			[[ "$ans" = "" || "$ans" == [Nn] ]] && ans=s
		fi
	elif [[ "$ans" != [Aa] ]]; then
		ans=""
	fi
	if [[ "$ans" != [SsAa] ]]; then
		ans=""
		while [[ "$ans" == [EeLlHh] || "$ans" = "" ]]; do
			if [[ "$ans" == [Ee] ]]; then
				read -e -p "edit> " cmd
			elif [[ "$ans" == [Ll] ]]; then
				range=`echo $cmd | awk '{ print $(NF-1) ".." $NF }'`
				listcmd="git log --reverse --pretty=format:\"%h %s\" $range";
				{ echo $listcmd; echo; /bin/sh -c "$listcmd"; } | $PAGER
			elif [[ "$ans" == [Hh] ]]; then
				phelp;
			fi
			[[ "$ans" == [Aa] ]] || read -s -n 1 -p "$cmd [Y/n/a/e/i/l/q/?]: " ans; echo || exit 255
			[ "$ans" = "" ] && ans=y
			[ "$ans" = "?" ] && ans=h
		done
	fi
	if [[ "$ans" == [AaYy] ]]; then
		$cmd; status=$?
		if [ $status != 0 ] || [ $imode = 0 ]; then
			echo "rebase command exited with status $status."
			read -s -n 1 -p "Press any key to continue...";
			echo
		fi
	elif [[ "$ans" == [Ii] ]]; then 
		echo $cmd | sed "s/^git rebase /git rebase --interactive /" | sh;
	elif [[ "$ans" == [SsNn] ]]; then
		echo Skipped...;
	else
		exit 0;
	fi
}
\EOF

awk -vpname="$0" -vflagstr="$flags" -vdepfile="$depfile" -vtagsfix="$tagsfix" '
function bname(b,
	n, a, u)
{
	n = split(b, a, /:/);
	b = a[1];
	if (n > 1)
		ubs[b] = a[2];
	return b;
}

function mkdep(newbase, b,
	n, a)
{
	b = bname(b);
	nb = bname(newbase);
	deps[b] = nb;
	depsidx[ndeps++] = b;
	if (deps[nb] == "")
		root_branch = nb;
#	print "mkdep", bname(b), bname(newbase) > "/dev/stderr"
}

function parsedep(fname,
	s, lnum, a, n, i)
{
	lnum = 0;
	while ((getline s < fname) > 0) {
		lnum++;
		if (substr(s, 1, 1) == "#")
			continue;
		n = split(s, a);
		if (!n)
			continue;
		if (root_branch == "")
			root_branch = a[1];
		for (i = 2; i <= n; i++)
			mkdep(a[i-1], a[i]);
	}
}

#
# set all branches b depends on in array "a"
# and return the number of matches found
#
function getdeps(b, a,
	i, nd)
{
	nd = 0;
	for (i = 0; i < ndeps; i++) {
		db = depsidx[i];
		if (deps[db] == b)
			a[nd++] = db;
	}

	return nd;
}

function ptree(b, indent,
	i, nd, a)
{
	printf("echo \"%s%s\"\n", indent, b);
	nd = getdeps(b, a);
	for (i = 0; i < nd; i++)
		ptree(a[i], indent ichar);
}

function rebase_tree(cmd, b, indent,
	i, nd, a, db, u)
{
	nd = getdeps(b, a);
	for (i = 0; i < nd; i++) {
		db = a[i];
		u = ubs[db];
		if (u == "")
			u = b tagsfix
		print "do_branch", "\"" cmd "\"", b, u, db, " $ans";
		rebase_tree(cmd, db, indent ichar);
	}
}

function mktags(b, force,
	i, nd, a)
{
	printf("git tag %s %s%s %s\n", force ? "-f" : "", b, tagsfix, b);
	tags[ntags++] = b;
	nd = getdeps(b, a);
	for (i = 0; i < nd; i++)
		mktags(a[i], force);
}

function rmtags( i)
{
	for (i = 0; i < ntags; i++)
		if (tags[i] != "") {
			printf("git tag -d %s%s\n", tags[i], tagsfix);
			delete tags[i];
		}
	ntags = 0;
}

BEGIN {
	ichar = "\t";

	for (i = 1; i <= length(flagstr); i++)
		flags[substr(flagstr, i, 1)]++;

	if (ARGC <= 2)
		parsedep(depfile);
	else for (i = 2; i < ARGC; i++)
		mkdep(ARGV[i-1], ARGV[i]);

	nbase = 0;
	if (ARGC < 2) {
		b = root_branch;
		if (flags["c"]) {
			cmd = "git branch";
			while (cmd | getline s > 0) {
				n = split(s, a);
				if (n == 2) {
					b = a[2];
					break;
				}
			}
			close(cmd);
		}
		ibs[nbase++] = b;
		ubs[b] = b tagsfix;
	} else
		ibs[nbase++] = bname(ARGV[1]);

	cmd="git rebase" (flags["i"] ? " --interactive" : "");

	printf("ans=%s\n", flags["a"] ? "a" : "y");
	for (n = 0; n < nbase; n++) {
		b = ibs[n];
		nbs = 0;
		bs[nbs++] = b;
		if (flags["t"] || !(flags["n"] || flags["p"]))
			mktags(b, flags["f"]);

		if (flags["p"])
			ptree(b, "");
		else if (!flags["t"])
			rebase_tree(cmd, b, ichar);

		if (flags["r"])
			rmtags();
	}
}' "$@" >> $cmdfile

bash $cmdfile && rm $cmdfile

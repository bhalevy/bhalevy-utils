#!/bin/sh
#
# Copyright (c) 2008 Benny Halevy <bhalevy@panasas.com>
#
pname=`basename $0`
depfile="$pname.dep"
cmdfile="$pname-cmd.$$"
flags=""

usage()
{
	{
	echo "Usage: $pname [options] [newbase[:oldbase] ...]"
	echo "Options:"
	echo "  -f Force creation of new tags"
	echo "  -h display this Help message"
	echo "  -i git-rebase --Interacive mode"
	echo "  -r Remove tags when done"
	echo "  -t just make Tags"
	} 1>&2
	exit 1
}

while [[ "$1" == -* ]]; do
	case "$1" in
	-[firt]*)
		flags=$flags`echo $1 | sed 's/-//'`;;
	-*)
		usage;;
	esac
	shift
done

cat <<EOF > $cmdfile
#!/bin/bash
#
# shell script automatically generated by $pname
#
# Copyright (c) 2008 Benny Halevy <bhalevy@panasas.com>
#
EOF

cat <<\\EOF >> $cmdfile

[ "$PAGER" = "" ] && PAGER=less

phelp () {
	echo "  y: Yes, do rebase (default)"
	echo "  n: No, skip rebase"
	echo "  a: Automatic mode"
	echo "  e: Edit rebase command"
	echo "  i: Interactive rebase"
	echo "  l: List changes in base..branch"
	echo "  q: Quit program"
}

do_branch () {
	cmd=$1
	newbase=$2
	upstream=$3
	branch=$4
	ans=$5
	cmd="$cmd --onto $newbase $upstream $branch"
	t=`git-show-ref --hash --heads --tags $newbase`
	if git-log --pretty=format:%H "$newbase^..$branch" | grep -q $t; then
		if [[ "$ans" == [Aa] ]]; then
			ans=s
		else
			read -p "$branch seems to be already based at $newbase. Rebase anyway [y/N]? " ans
			[[ "$ans" = "" || "$ans" == [Nn] ]] && ans=s
		fi
	elif [[ "$ans" != [Aa] ]]; then
		ans=""
	fi
	if [[ "$ans" != [SsAa] ]]; then
		ans=""
		while [[ "$ans" == [EeLlHh] || "$ans" = "" ]]; do
			if [[ "$ans" == [Ee] ]]; then
				read -e -p "edit> " cmd
			elif [[ "$ans" == [Ll] ]]; then
				range=`echo $cmd | awk '{ print $(NF-1) ".." $NF }'`
				listcmd="git-log --reverse --pretty=format:\"%h %s\" $range";
				{ echo $listcmd; echo; /bin/sh -c "$listcmd"; } | $PAGER
			elif [[ "$ans" == [Hh] ]]; then
				phelp;
			fi
			[[ "$ans" == [Aa] ]] || read -s -n 1 -p "$cmd [Y/n/a/e/i/l/q/?]: " ans; echo || exit 255
			[ "$ans" = "" ] && ans=y
			[ "$ans" = "?" ] && ans=h
		done
	fi
	if [[ "$ans" == [AaYy] ]]; then 
		$cmd;
	elif [[ "$ans" == [Ii] ]]; then 
		echo $cmd | sed "s/^git-rebase /git-rebase--interactive /" | sh;
	elif [[ "$ans" == [SsNn] ]]; then
		echo Skipped...;
	else
		exit 0;
	fi
}
\EOF

awk -vpname="$0" -vflagstr="$flags" -vdepfile="$depfile" '
function parsedep(fname,
	s, lnum, a, n, i)
{
	lnum = 0;
	while ((getline s < fname) > 0) {
		lnum++;
		if (substr(s, 1, 1) == "#")
			continue;
		n = split(s, a);
		if (n < 2) {
			printf("%s: %s:%d: branch dependency line must contain at least two words\n",
				ARGV[0], fname, lnum) > "/dev/stderr";
			exit(1);
		}
		for (i = 2; i <= n; i++) {
			d[a[i]] = a[i-1];
#			print a[i-1], a[i] > "/dev/stderr";
		}
	}
}

function mktags(b, force,
	j)
{
	printf("git-tag %s %s.orig %s\n", force ? "-f" : "", b, b);
	tags[ntags++] = b;
	for (j in d)
		if (d[j] == b)
			mktags(j, force);
}

function rmtags( i)
{
	for (i = 0; i < ntags; i++)
		if (tags[i] != "") {
			printf("git-tag -d %s.orig\n", tags[i]);
			delete tags[i];
		}
	ntags = 0;
}

BEGIN {
	for (i = 1; i <= length(flagstr); i++)
		flags[substr(flagstr, i, 1)]++;

	parsedep(depfile);

	cmd="git-rebase" (flags["i"] ? "--interactive" : "");

	nbase = 0;
	if (ARGC <= 1) {
		ibs[nbase] = "master";
		ubs[nbase++] = "master.orig";
	} else for (nbase = 0; nbase < ARGC-1; nbase++) {
		b = ARGV[nbase+1];
		delete ARGV[nbase+1];
		split(b, a, /:/);
		if (a[2] == "")
			a[2] = b ".orig";
		ibs[nbase] = a[1];
		ubs[nbase] = a[2];
	}
	print "ans=y";
	for (n = 0; n < nbase; n++) {
		bs[0] = ibs[n];
		us[0] = ubs[n];
		mktags(ibs[n], flags["f"]);

		found = 1;
		while (found && !flags["t"]) {
			found = 0;
			for (i in bs) {
				b = bs[i];
				u = us[i];
				delete bs[i];
				for (j in d)
					if (d[j] == b) {
						bs[found] = j;
						us[found++] = j ".orig";
						print "do_branch", cmd, b, u, j, " $ans; status=$?";
#						print "if [ $status = 1 ]; then exit 0; elif [ $status != 0 ]; then exit $status; fi"
					}
			}
		}

		if (flags["r"])
			rmtags();
	}
}' $* >> $cmdfile

bash $cmdfile && rm $cmdfile
